<p><strong>LECTURE EIGHT</strong></p>
<p><strong>EXCEPTIONS</strong></p>
<p><strong>WHAT IS AN EXCEPTION<br /> </strong><br /> An exception is a condition that may arise during the execution of a Java program when a normal path of execution is not defined.<br /> <br /> For example, a Java program may encounter a numeric expression that attempts to divide an integer by zero.<br /> Such a condition may occur during the execution of the following snippet of code:<br /> <strong>&nbsp;&nbsp; int x = 10, y = 0, z;<br /> &nbsp;&nbsp; z = x/y; // Divide-by-zero<br /> </strong><br /> If you attempt to run the above code,&nbsp; several lines of information would be displayed in response to this invalid input.<br /> &nbsp;&nbsp; This information is known as a stack trace, which includes the name of the exception (java.lang.ArithmeticException) in a descriptive<br /> message that indicates the problem that occurred and the method-call stack (i.e., the call chain) at the time it occurred. The stack trace includes the path of execution that led to<br /> the exception method by method. This helps you debug the program. The first line specifies that an ArithmeticException has occurred. The text after the name of the exception ("/ by zero") indicates that this exception occurred as a result of an attempt to divide by<br /> zero. Java does not allow division by zero in integer arithmetic.<br /> &nbsp;&nbsp;&nbsp;&nbsp; When this occurs, Java throws an ArithmeticException. ArithmeticExceptions can arise from a number of different problems in arithmetic, so the extra data (""/ by zero") provides more specific information<br /> <br /> &nbsp;&nbsp; A Java exception is an object that describes an exceptional (that is, error) condition<br /> that has occurred in a piece of code. When an exceptional condition arises, an object<br /> representing that exception is created and thrown in the method that caused the error. That<br /> method may choose to handle the exception itself, or pass it on. Either way, at some point,<br /> the exception is caught and processed. Exceptions can be generated by the Java run-time<br /> system, or they can be manually generated by your code.<br /> <br /> <strong><u>In summary, Exception occurs when :<br /> </u></strong><br /> <strong>&nbsp;&nbsp; 1)&nbsp; user entered invalid data<br /> &nbsp;&nbsp; 2)&nbsp; open non existing file<br /> &nbsp;&nbsp; 3)&nbsp; network problem<br /> &nbsp;&nbsp; 4)&nbsp; data needed is out of prescribed range<br /> &nbsp;&nbsp; 5)&nbsp; missing loaded class.<br /> </strong>&nbsp;&nbsp;&nbsp; e.t.c.<br /> <br /> <strong>TYPES OF EXCEPTION<br /> </strong><br /> &nbsp;&nbsp; <strong>1)&nbsp; CHECKED EXCEPTIONS<br /> &nbsp;&nbsp; 2)&nbsp; UNCHECKED EXCEPTIONS</strong><br /> <br /> <strong>CHECKED EXCEPTIONS<br /> </strong><br /> &nbsp;&nbsp; Checked exceptions occur at compile time&nbsp; and cannot be ignored by the compiler at the point of compilation.&nbsp; All classes that inherit from class Exception but not class RuntimeException are considered to be checked exceptions.<br /> <br /> Such exceptions are typically caused by conditions that are not under the control of the program. for example, in file processing, the program can't open a file because the file does not<br /> exist.<br /> <br /> <strong><u>Examples of checked exceptions are :<br /> </u></strong><br /> ClassNotFoundException, IOException, SQLException, IllegalAccessException, DataAccessException e.t.c<br /> <br /> <strong>UNCHECKED EXCEPTIONS :<br /> </strong><br /> &nbsp;&nbsp; Unchecked exceptions are exceptions that occur at the time of execution called runtime exceptions. All exception<br /> types that are direct or indirect subclasses of class RuntimeException (package java.lang)<br /> are unchecked exceptions. These are typically caused by defects in your program's code<br /> <br /> <strong><u>Examples of unchecked Exceptions are :<br /> </u></strong><br /> ArrayIndexOutOfBoundsExceptions, ArithmeticExceptions, NullPointerException, <br /> &nbsp;InputMismatchException, ClassCastException e.t.c.<br /> <br /> <strong>HANDLING EXCEPTIONS<br /> </strong><br /> &nbsp;&nbsp; Java exception handling is managed via five keywords: try, catch, throw, throws, and<br /> finally. Briefly, here is how they work. Program statements that you want to monitor for<br /> exceptions are contained within a try block. If an exception occurs within the try block,<br /> it is thrown. Your code can catch this exception (using catch) and handle it in some<br /> rational manner. System-generated exceptions are automatically thrown by the Java runtime system. To manually throw an exception, use the keyword throw. Any exception that is thrown out of a method must be specified as such by a throws clause. Any code that<br /> absolutely must be executed after a try block completes is put in a finally block.<br /> <br /> <strong><u>This is the general form of an exception-handling block:<br /> </u></strong><br /> <strong>try {<br /> // block of code to monitor for errors<br /> }<br /> catch (ExceptionType1 exOb) {<br /> // exception handler for ExceptionType1<br /> }<br /> catch (ExceptionType2 exOb) {<br /> // exception handler for ExceptionType2<br /> }<br /> // ...<br /> finally {<br /> // block of code to be executed after try block ends<br /> }<br /> </strong><br /> Here, ExceptionType is the type of exception that has occurred. <br /> <br /> <strong><u>Using try and catch<br /> </u></strong><br /> &nbsp;&nbsp; To guard against and handle a run-time error, simply enclose the code that you want to<br /> monitor inside a try block. Immediately following the try block, include a catch clause that<br /> specifies the exception type that you wish to catch. To illustrate how easily this can be done,<br /> the following program includes a try block and a catch clause that processes the<br /> ArithmeticException generated by the division-by-zero error:<br /> <br /> <strong>class Exc2 {<br /> public static void main(String args[]) {<br /> int d, a;<br /> try { // monitor a block of code.<br /> d = 0;<br /> a = 42 / d;<br /> System.out.println("This will not be printed.");<br /> } catch (ArithmeticException e) { // catch divide-by-zero error<br /> System.out.println("Division by zero.");<br /> }<br /> System.out.println("After catch statement.");<br /> }<br /> }<br /> </strong>This program generates the following output:<br /> <br /> Division by zero.<br /> After catch statement.<br /> <br /> Notice that the call to println( ) inside the try block is never executed. Once an exception<br /> is thrown, program control transfers out of the try block into the catch block. Put differently,<br /> catch is not "called," so execution never "returns" to the try block from a catch. Thus, the<br /> line "This will not be printed." is not displayed. Once the catch statement has executed,<br /> program control continues with the next line in the program following the entire try /<br /> catch mechanism.<br /> <br /> &nbsp;&nbsp; A try and its catch statement form a unit. The scope of the catch clause is restricted to<br /> those statements specified by the immediately preceding try statement. A catch statement<br /> cannot catch an exception thrown by another try statement (except in the case of nested<br /> try statements, described shortly). The statements that are protected by try must be<br /> surrounded by curly braces. (That is, they must be within a block.) You cannot use try<br /> on a single statement.<br /> <br /> <strong>FINALLY BLOCK<br /> </strong><br /> &nbsp;&nbsp; The finally block (which consists of the finally keyword, followed by code<br /> enclosed in curly braces), sometimes referred to as the finally clause, is optional. If it's<br /> present, it's placed after the last catch block. If there are no catch blocks, the finally<br /> block immediately follows the try block.<br /> <br /> The finally block will execute whether or not an exception is thrown in the corresponding<br /> try block. The finally block also will execute if a try block exits by using a<br /> return, break or continue statement or simply by reaching its closing right brace. The<br /> finally block will not execute if the application exits early from a try block by calling<br /> method System.exit.</p>
<p>&nbsp;</p>
<p>**********End of LECTURE EIGHT**********</p>